---
layout: post
title: 'Follow Up: A Binary Proof and a Trinary Clock'
date: '2015-01-11T16:55:00.001-08:00'
author: Oatzy
tags:
- time
- binary
- clock
- nerd
- proofs
- android
- maths
modified_time: '2015-03-14T15:38:48.874-07:00'
thumbnail: http://2.bp.blogspot.com/-OlVcFcleaaE/VLA2jCh2BrI/AAAAAAAABTY/1eEEa8hIvyA/s72-c/Screenshot_2015-01-05-15-52-58.png
blogger_id: tag:blogger.com,1999:blog-14769935.post-7939085758103022734
blogger_orig_url: https://oatzy.blogspot.com/2015/01/follow-up-binary-proof-and-trinary-clock.html
---

In the <a href="http://oatzy.blogspot.co.uk/2015/01/metric-and-binary-clocks-for-android.html">last blog</a> I talked about making a binary clock widget (for Android) using <a href="https://play.google.com/store/apps/details?id=org.zooper.zwfree&amp;hl=en_GB">Zooper</a>, and I made a claim about how individual binary digits can be extracted from a decimal number - what follows is an explanation/proof of why it works.<br /><br /><br /><b>The Claim</b><br /><br />The n-th digit of the binary representation of a number, x, is a zero if \(x \bmod 2^{n+1} \lt 2^{n}\), or a one otherwise.<br /><br /><b>Proof</b><br /><br />To start, we express our number x as a sum of powers of 2. This makes sense, since this is basically how binary works. So we have<br /><br />\[ x = \sum_{i=0} a_{i} 2^{i}\]<br />where the \(a_i\) equal either 1 or 0 - these are equivalent to the i-th digits in the binary form of the number (reading right to left). For example, if x=5 then \(a_0=1, a_1=0, a_2=1\) and all other \(a_i=0\) (since 5 in binary is 101).<br /><br />So lets split the sum up into three parts and expand<br /><br />\[\begin{align*}<br />x &amp;=\ a_{n} 2^{n} \ +\ \sum_{i=0}^{n-1} a_{i}2^{i} \ +\ \sum_{i=n+1} a_{i} 2^{i} \\ \\<br />&amp;= a_{n} 2^{n} \\<br />&amp;+ (a_{0}2^{0} + a_{1}2^1 + \ldots + a_{n-1}2^{n-1}) \\<br />&amp;+ (a_{n+1}2^{n+1} + a_{n+2} 2^{n+2}+ a_{n+3} 2^{n+3}+\ldots)<br />\end{align*}\]<br />Notice that in the second set of brackets, all the terms are divisible by \(2^{n+1}\) - so if we take mod \(2^{n+1}\), all of those terms disappear<br /><br />\[ x \bmod 2^{n+1} = a_{n} 2^{n} + (a_{0}2^{0} + a_{1}2^1 + \ldots + a_{n-1}2^{n-1}) \]<br />The terms in the remaining set of brackets <a href="https://en.wikipedia.org/wiki/Geometric_series">sum to</a> some value between 0 and \(2^{n}-1\) (depending on the values of the \(a_i\)). We'll call this \(\sigma\) for convenience.<br /><br />Therefore, if \(a_n = 1\) then <br /><br />\[ x \bmod 2^{n+1} = 2^{n} + \sigma \ge 2^{n}\]<br />And if \(a_n = 0\) then <br /><br />\[ x \bmod 2^{n+1} = \sigma \le (2^{n} - 1) \lt 2^{n}\]<br />QED<br /><br /><br /><b>Generalisation</b><br /><br />As with powers of 2, we can write numbers as the sum of powers of any number/base. For example, we can write 11 as \(2\cdot 3^0 + 0\cdot 3^1 + 1\cdot 3^2\) - or to put it another way, 11 in base 3 is 102.<br /><br />So in general, we can write a number 'x' in terms some base 'b' as<br /><br />\[ x = \sum_{i=0} a_{i} b^{i}\]<br />where the \(a_i\) are whole numbers between 0 and (b-1) - equivalent to the i-th digits of x in base 'b'. So for example, for x=11 and b=3 we'd have \(a_0 = 2, a_1 = 0, a_2 = 1\) and \(a_i=0\) for all other i.<br /><br />As before, we can split the summation and expand. But this time we're going to divide through by \(b^n\) as well<br /><br />\[\begin{align*}<br />\frac{x}{b^n} &amp;=\ a_{n} \ +\ \frac{1}{b^n}\sum_{i=0}^{n-1} a_{i}b^{i} \ +\ \frac{1}{b^n}\sum_{i=n+1} a_{i} b^{i} \\ \\<br />&amp;= a_{n} \\<br />&amp;+ \frac{1}{b^n}(a_{0}b^{0} + a_{1}b^1 + \ldots + a_{n-1}b^{n-1}) \\<br />&amp;+ (a_{n+1}b^{1} + a_{n+2} b^{2} + a_{n+3} b^{3}+\ldots)<br />\end{align*}\]<br />And now, all the terms in the last bracket are divisible by just 'b', so taking a modulo of 'b' will make those terms disappear. So we have <br /><br />\[ \frac{x}{b^n} \bmod b = a_n + \varepsilon \] <br />where \(\varepsilon \le \frac{b^{n}-1}{b^{n}} \lt 1 \).<br /><br />And from this, we can define a general function for extracting \(a_n\) - the n-th digit of x in base 'b' - as <br /><br />\[ D^{n}_{b}(x) = \left \lfloor{ \frac{x}{b^{n}} \bmod b }\right \rfloor\]<br />where the brackets mean 'floor', or round down to the nearest whole number - basically, get rid of \(\varepsilon\).<br /><br />So as an example, the zeroth and first digits of 35 in base 16 (hexadecimal) are<br /><br />\[ D_{16}^{0}(35) = \left \lfloor{ \frac{35}{16^{0}} \bmod 16 }\right \rfloor = \left \lfloor{ 35 \bmod 16 }\right \rfloor&nbsp; = 3 \\ D_{16}^{1}(35) = \left \lfloor{ \frac{35}{16^{1}} \bmod 16 }\right \rfloor = \left \lfloor{ 2.1875 \bmod 16 }\right \rfloor&nbsp; = 2\]<br />So 35 in hexadecimal is 23. Easy.<br /><br /><br /><b>Trinary Clock&nbsp; </b><a href="https://www.dropbox.com/s/xfxtzcqxtsxs164/trinary-clock.zw?dl=0">[download]</a><br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-OlVcFcleaaE/VLA2jCh2BrI/AAAAAAAABTY/1eEEa8hIvyA/s1600/Screenshot_2015-01-05-15-52-58.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-OlVcFcleaaE/VLA2jCh2BrI/AAAAAAAABTY/1eEEa8hIvyA/s1600/Screenshot_2015-01-05-15-52-58.png" height="199" width="200" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">15:52</td></tr></tbody></table><br />The thing is, binary clocks are great and all. But they're old hat. So now we have a way of finding the individual digits of a number in any base, we can make something a little more unique - a trinary clock.<br /><br /><a href="http://oatzy.blogspot.co.uk/2015/01/metric-and-binary-clocks-for-android.html">Before</a>, when I constructed the binary clock, I used rectangles for each binary digit, which changed colour depending on whether the digit it represented was a one or a zero. For a trinary clock we'd need each rectangle to have 3 state - 0, 1, 2. The problem is, Zooper can only do 2-state logic - if-then-else - not else-ifs, and no nested if-statements. So we can't make a rectangle that switches between 3 colours.<br /><br />Instead, I made each segment a progress bar with values 0-2. For the current value of each bar/digit, we can use the formula we found above - \(D^{n}_{3}(x) = \frac{x}{3^n} \bmod 3\).<br /><br />For example, for the 3rd segment (n=2) of the hours ring, we'd set the current value to<br /><br /><pre class="brush: plain">$(#DH#/9) % 3$</pre><br />The progress bar automatically rounds values down to the nearest whole number, so we don't have to worry about getting rid of any decimals. But you could add a 'floor' function if you wanted. <br /><br />Like the binary clock, I made the sizes of each segment proportional to the values they represent - the three-segment is 3 times bigger than the one-segment, etc. And to make reading clearer, I've made the leading edge of each segment a darker blue - that way it's easier to tell where one segment ends and the next one begins. <br /><br /><br /><b>Quinary (Base 5) Clock&nbsp; </b><a href="https://www.dropbox.com/s/qf8rpja23i334c7/quintary-clock.zw?dl=0">[download]</a><br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-Z_TeN5fNBAA/VLA1OKaN1WI/AAAAAAAABTM/hq3bvehdo-Q/s1600/Screenshot_2015-01-05-22-44-54.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://3.bp.blogspot.com/-Z_TeN5fNBAA/VLA1OKaN1WI/AAAAAAAABTM/hq3bvehdo-Q/s1600/Screenshot_2015-01-05-22-44-54.png" height="200" width="199" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">22:44</td></tr></tbody></table><br />Once you've figured out the trinary clock, adapting it to other bases is very straightforward.<br /><br /><br /><b>Decary (Base 10) Clock&nbsp; </b><a href="https://www.dropbox.com/s/q181cj6qh8vxvk9/decary-clock.zw?dl=0">[download]</a><b></b><br /><b><br /></b><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-Z__5e__rY2A/VLAY3U4FuOI/AAAAAAAABS8/qLYZzAJCAuA/s1600/Screenshot_2015-01-06-22-16-19.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-Z__5e__rY2A/VLAY3U4FuOI/AAAAAAAABS8/qLYZzAJCAuA/s1600/Screenshot_2015-01-06-22-16-19.png" height="200" width="198" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">22:16</td></tr></tbody></table><br />You get the idea...<br /><br /><br /><b>Finally</b><br /><br />As far as telling the time goes, all the clocks in this and the previous blog are pretty... challenging. At least until you get the hang of it. But they look cool. And that, I think is worth the extra effort. If I ever get a smartwatch I'll probably try to port some of these designs over. And if/when I do, you can bet I'll post them here.<br /><br />[edit] - Android Wear versions are <a href="http://oatzy.blogspot.co.uk/2015/03/watch-face-concepts-for-android-wear.html">here</a>.<br /><br /><br />Oatzy.<br /><br /><br />[Decary? Really..?]