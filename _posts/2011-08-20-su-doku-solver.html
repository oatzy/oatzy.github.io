---
layout: post
title: Su Doku Solver
date: '2011-08-20T19:41:00.000-07:00'
author: Oatzy
tags:
- programming
- su doku
- nerd
- python
- infographic
- problem solving
- hand-waving
modified_time: '2011-08-21T06:53:17.734-07:00'
thumbnail: http://3.bp.blogspot.com/-0dwLttUVzCc/TlBIXgdaafI/AAAAAAAAAps/SFNJitSBv9c/s72-c/puzzle.png
blogger_id: tag:blogger.com,1999:blog-14769935.post-2031990312790562501
blogger_orig_url: https://oatzy.blogspot.com/2011/08/su-doku-solver.html
---

<b>Cold Hard Logic </b><br /><br />Let's be frank, <a href="http://en.wikipedia.org/wiki/Su_doku">Su Doku</a> solvers are dime a dozen. My favourite is the one in <a href="http://www.google.com/mobile/goggles/#text">Google Goggles</a> - you point your camera at a puzzle and it uses OCR to interpret it, then solves it for you. None of that faffing with inputting the puzzle by hand. Anyway.<br /><br />At the most basic level, computers run on maths and logic. So logic puzzles <i>should</i> be easy for computers to solve - it's just following a collection of logical rules. No creative thinking required.<br /><br />The problem are,<br /><br />1) Inputting a problem in a form that the computer can parse (understand)<br />2) Translating the logical rules into a form the computer can apply<br />3) Applying said rules to a given input problem to find its solution.<br /><br />Here's the main puzzle I'll be using as the example for this post [<a href="http://www.conceptispuzzles.com/index.aspx">source</a>]. Feel free to try and solve it yourself before continuing (it should be easy).<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-0dwLttUVzCc/TlBIXgdaafI/AAAAAAAAAps/SFNJitSBv9c/s1600/puzzle.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="http://3.bp.blogspot.com/-0dwLttUVzCc/TlBIXgdaafI/AAAAAAAAAps/SFNJitSBv9c/s200/puzzle.png" width="193" /></a></div><br /><b>The Rules</b><br /><br />So what are the rules? In the traditional version you're presented with a 9x9 grid, with some numbers already filled in. The idea is to enter into the grid the numbers 1-9, so that each number appears only once in each row, column, or box (3x3 square).<br /><br />So that's fairly straight forward. But in that particular form, the rules are really only good for checking if your solution is right. <br /><br /><br /><b>Brute Force </b><br /><br />This <i>can</i> be use in a <a href="http://en.wikipedia.org/wiki/Brute-force_search">brute-force</a> approach to solving, e.g.<br /><br />1) Stick numbers in empty squares at random <br />2) If any of the numbers break the rules, try again<br />3) Repeat until the right solution is found. <br /><br />But that's incredibly inefficient and inelegant, and certainly not the way it's solved by people in the real world.<br /><br />As an example, say our placement technique is this - take the numbers missing from each row, and just shuffle them around within their given row.<br /><br />[There are probably better brute-force methods.] <br /><br />If we use this approach on the puzzle above, there are <i>~4.95E26</i> possible number placements (<a href="http://en.wikipedia.org/wiki/Permutations">permutations</a>), of which only one is correct. Say our computer can check <i>1 billion</i> <i>solutions per second</i>, it would take <i>16 billion years</i> to solve. Which is about <i>2 billion years</i> longer than the current <a href="http://en.wikipedia.org/wiki/Age_of_the_universe">age of the universe</a>.<br /><br />As a ball park estimate, the general formula for the number of permutations for a grid of side <i>n</i> is given by -&gt; <i>((n-a)<a href="http://en.wikipedia.org/wiki/Factorial">!</a>)^n&nbsp; - </i>Where <i>a</i> is the average number of numbers already placed in each row. <br /><br />If, for example, we try to solve a 16-grid with <i>a=8</i> (half the numbers already placed), then the number of possible permutations is a mind-meltingly inconceivable <i>4.88x10^73</i>. At <i>1 billion checks per second</i>, that would take <i>1.5x10^57 years</i> to solve - <i>1 billionth</i> the lifespan of a black hole with the mass of the sun (<a href="http://en.wikipedia.org/wiki/1_E19_s_and_more">according to wikipedia</a>).<br /><br />This is an example of a <i>non-polynomial</i> time (NP) algorithm. More on that later.<br /><br /><br /><b>Rewriting the Rules</b><br /><br />The rules can be re-interpreted and applied in two fundamental ways<br /><br />1) <i>Which is the only square this number can appear in?</i><br /><br />That is, a particular number has to go in one particular square, because if you try to put it in any other square in that row (or column, or box) it will break the rules.<br /><br />This is the most common approach in real world solving - that is, "three can't go in that row, or those columns because they already have threes in them, so it must go there" sort of thing.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-H8zdOOhoMm0/TlBJNqmXK-I/AAAAAAAAApw/g1liNVd-Op4/s1600/sudoku-method1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="http://1.bp.blogspot.com/-H8zdOOhoMm0/TlBJNqmXK-I/AAAAAAAAApw/g1liNVd-Op4/s200/sudoku-method1.png" width="193" /></a></div><br />2) <i>What is the only number that can go in this square?</i><br /><br />That is, if every other number already appears in the same row, column, or box as a given square, then that square can only be one particular number.<br /><br />This is most obvious in the case where every other number in a given row is already filled in, but can also be used by considering all the rows, columns and boxes a square belongs to.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-6D_uZK0IPLs/TlBJuisp_6I/AAAAAAAAAp0/O4adrxEH3fQ/s1600/sudoku-method2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="http://3.bp.blogspot.com/-6D_uZK0IPLs/TlBJuisp_6I/AAAAAAAAAp0/O4adrxEH3fQ/s200/sudoku-method2.png" width="193" /></a></div>This tends to be required more in the harder puzzles; you could probably solve the above puzzle by Rule One alone.<br /><br /><br /><b>Setting Up The Problem</b><br /><br />First of all, we create our grid. We can refer to each square in the grid by a sort of coordinate - <i>(i,j)</i> - with the square in the top left corner being <a href="http://en.wikipedia.org/wiki/Zero-based_numbering"><i>(0,0)</i></a> and the square in the bottom right being <i>(8,8)</i><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-Te5C3tezZu8/TlBKGFNGV5I/AAAAAAAAAp4/r8m9rwwGkAA/s1600/co-ordinates.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="http://3.bp.blogspot.com/-Te5C3tezZu8/TlBKGFNGV5I/AAAAAAAAAp4/r8m9rwwGkAA/s200/co-ordinates.png" width="200" /></a></div>We reference <i>Row i</i> as the set <i>{(i,j) : j in [0,8]} </i>and<i> Column j</i> as <i>{(j,i) : j in [0,8]}</i><br /><br />For boxes, we note that the index for the top-left square of each box are multiples of 3 - (0,0) (0,3) (0,6) (3,0) etc<i>. So, Box (m,n)</i> is given as <i>{(3m+i,3n+j) : i,j in [0,2]}</i> for <i>m,n in [0,2]</i><br /><br />So from this we can, for example, check the correctness of a puzzle (by rows) like this:<br /><blockquote style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="color: orange;">for</span> i <span style="color: orange;">in</span> <span style="color: purple;">range</span>(0,9):<br />&nbsp;&nbsp;&nbsp; <span style="color: orange;">for</span> j <span style="color: orange;">in</span> <span style="color: purple;">range</span>(0,8):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: orange;">for</span> k <span style="color: orange;">in</span> <span style="color: purple;">range</span>(j+1,9):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: orange;">if</span> Grid[i][j] == Grid[i][k]:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: orange;">return</span> <span style="color: #274e13;">"incorrect puzzle"</span></blockquote>Checking columns and boxes works similarly.<br /><br /><br />If we have a fancy GUI, then inputting and parsing the grid is pretty straight forward. But we don't. So instead, we input the puzzle as one long string -&gt; <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">puzzle = </span><span style="color: #38761d; font-family: &quot;Courier New&quot;,Courier,monospace;">"???36?9???2?.."</span><br /><br /><span style="color: #38761d;"><span style="color: black;">The first row is given by the characters (numbers) numbered [0,..,8], the second row is [9,..,17], and so on. In general, <i>row i</i> is the set of characters with index [9i,..,9i+j,...,9i+8].&nbsp;</span></span><br /><br /><span style="color: #38761d;"><span style="color: black;">Parsing our puzzle into the Grid works like this then:</span><br /></span><br /><blockquote style="font-family: &quot;Courier New&quot;,Courier,monospace;"><div style="text-align: left;"><span style="color: orange;">for</span> i <span style="color: orange;">in</span> <span style="background-color: white; color: purple;">range</span>(0, 9):</div><div style="text-align: left;">&nbsp;&nbsp;&nbsp; <span style="color: orange;">for</span> j <span style="color: orange;">in</span> <span style="color: purple;">range</span>(0, 9):</div><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Grid[i][j] = puzzle[9i+j]</div></blockquote>And so on..<br /><br /><br /><b>Applying the Rules</b><br /><br />Now, if you've done Su Dokus, you might be familiar with the technique of filling each square with the numbers one to nine and eliminating numbers as appropriate. That's basically the bulk of how this solver works:<br /><br />1) Assign to each empty square (<span style="color: #38761d;">"?"</span>) the set <i>[1,...,9]</i><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-lRGe3xXX_qU/TlBLLvnFKbI/AAAAAAAAAqE/ltZWsObHNps/s1600/number-sets-cropped.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-lRGe3xXX_qU/TlBLLvnFKbI/AAAAAAAAAqE/ltZWsObHNps/s1600/number-sets-cropped.png" /></a></div>2) For each number in a given square's set:<br />&nbsp;&nbsp;&nbsp; a) Check to see if that number is already fixed in another square in the same row, column, or box as the square in question. If so, eliminate the number from that square's set.<br /><br />3) Repeat for all squares in the grid<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-3V0-Oli5jvQ/TlBLbFGj8XI/AAAAAAAAAqM/5KANqN-D5xQ/s1600/number-sets-elim-crop.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="134" src="http://2.bp.blogspot.com/-3V0-Oli5jvQ/TlBLbFGj8XI/AAAAAAAAAqM/5KANqN-D5xQ/s320/number-sets-elim-crop.png" width="136" /></a></div>From there, we can apply <i>Rule Two</i>: <br /><br />4) For each square:<br />&nbsp;&nbsp;&nbsp; a) if that square's set contains only one number, fix that square's value accordingly.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-Jc14mzFkGSg/TlBRbo717tI/AAAAAAAAAqU/3p8DrBmSpDw/s1600/rule2-example.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-Jc14mzFkGSg/TlBRbo717tI/AAAAAAAAAqU/3p8DrBmSpDw/s1600/rule2-example.png" /></a></div>5) Go back to (2). Repeat until no more squares can be fixed.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-BesVY68IbbM/TlBRhGXh5VI/AAAAAAAAAqc/zJfNHIUMcfU/s1600/elim-seq.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="92" src="http://4.bp.blogspot.com/-BesVY68IbbM/TlBRhGXh5VI/AAAAAAAAAqc/zJfNHIUMcfU/s400/elim-seq.png" width="400" /></a></div><br />You can actually created a shortcut for this - create a collection of sets for each row (etc.), which contain the values already fixed in that row. That way, instead of checking every square along each row for fixed values, you just check in that row's set. (Trust me, it's easier.)<br /><br />Applying <i>Rule One</i> is easy as looking along each row (or column, or box) to see if a given number appears in only one of the squares.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-dma2s27FfkM/TlBSvnafSII/AAAAAAAAAqk/XFG5R22fXN4/s1600/ruleone-example.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="134" src="http://4.bp.blogspot.com/-dma2s27FfkM/TlBSvnafSII/AAAAAAAAAqk/XFG5R22fXN4/s320/ruleone-example.png" width="136" /></a></div>Or more technically,<br /><br />1) For a given row (etc), for each number 1-9:<br />&nbsp;&nbsp;&nbsp; a) count how many times that number appears in square sets in that row<br />&nbsp;&nbsp;&nbsp; b) if a number's count equals 1, fix the value of the square it appears in accordingly.<br /><br />2) If you fix any new squares this way, go back to <i>(2)</i> to see if that will allow you to set any more squares.<br /><br />You then just loop through rules <i>One</i> and <i>Two</i> until the puzzle is (hopefully) solved.<br /><br /><br /><b>One More 'Rule'</b><br /><br />In fact, this is just Rule Two, but with an added 'quirk'.<br /><br />Here's what happens if you apply the method, so far, to a more difficult puzzle<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-jMEyMAEEUMs/TlBUMN7uBXI/AAAAAAAAAqs/F2tb8jFB7cw/s1600/hard-stuck.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="http://1.bp.blogspot.com/-jMEyMAEEUMs/TlBUMN7uBXI/AAAAAAAAAqs/F2tb8jFB7cw/s200/hard-stuck.png" width="200" /></a></div>This is where the program gets stuck. What do you do from here? If we focus on the bottom-right corner box<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-Kn6dJJ6nqmQ/TlBUV50waoI/AAAAAAAAAq0/RTAXbHN0NM8/s1600/hard-bottomcorner.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="137" src="http://2.bp.blogspot.com/-Kn6dJJ6nqmQ/TlBUV50waoI/AAAAAAAAAq0/RTAXbHN0NM8/s320/hard-bottomcorner.png" width="134" /></a></div>Notice there are no squares that can take only one value, and no values that only appear in one of the squares.<br /><br />But look on that bottom row - the circled boxes can only take the values 3 or 5. What this means is that 3 and 5 can't go in any other of the squares in that box. So we eliminate 3s and 5s from the other squares in that box. Similarly for the 1/6 squares in the middle.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-mbWpRh-5Y8M/TlBUe_aN5kI/AAAAAAAAAq8/KSIRh1pKXyM/s1600/hard-bottomcorner-simp.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="136" src="http://3.bp.blogspot.com/-mbWpRh-5Y8M/TlBUe_aN5kI/AAAAAAAAAq8/KSIRh1pKXyM/s320/hard-bottomcorner-simp.png" width="136" /></a></div>We now have the square in the top-right of the box that can only be 8, and the middle-right that can only be 9. So we fix those values. And from there, it's pretty straight forward to solve the rest - going back to looping through <i>Rules</i> <i>Two</i> and <i>One</i>.<br /><br />Not only is it tricky to spot in real world solving, it's also tricky to translate it into computer logic. It mostly involves looking for pairs of squares in a box (etc.) which have matching sets of size two (or triplets, size 3, or etc.). Fortunately, this sort of thing doesn't come up often.<br /><br /><br /><b>A Note on <i>P versus NP</i></b><br /><br />So as mentioned above, it's easy enough to apply the standard rules (as states) to check if a solution is correct - you just check to make sure no number appears more than once in any given row, column, or box.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-fNL3kEJG9Hs/TlBaxcgCSpI/AAAAAAAAArM/uC6IOni_5hM/s1600/sudoku-solution-error-row.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="40" src="http://2.bp.blogspot.com/-fNL3kEJG9Hs/TlBaxcgCSpI/AAAAAAAAArM/uC6IOni_5hM/s320/sudoku-solution-error-row.png" width="320" /></a></div>It turns out, checking the correctness of a puzzle can be done in <a href="http://en.wikipedia.org/wiki/Polynomial_time#Polynomial_time">polynomial time</a> (fast). For a grid of side <i>n</i>, the time required to check a solution* is given by<i> -&gt; 3(n^3 - n)/2</i><br /><br />..Multiplied by the amount of time it takes a computer to work out if 2 numbers are equal or not (call this time t). So for a 9-grid, that time is <i>972t</i>.<br /><br />For a grid of side <i>n=100</i>, the time is <i>~1.5million t</i>. Which on a modern computer is peanuts. For example, if our hypothetical computer can check <i>1 billion</i> 9-grids in one second, then it can check <i>650,000</i> 100-grids in a second.<br /><br />By comparison, actually solving the puzzle - by the method outlined about, and by all other known methods - is done in <a href="http://en.wikipedia.org/wiki/Time_complexity">non-polynomial time</a>.<br /><br />What this means, is that if you apply this algorithm to a larger grid - say, a <i>25x25</i>, or a <i>36x36</i> grid - then the amount of time it will take to solve the puzzle increases <i>rapidly</i> (exponentially), to the point where a puzzle couldn't be solve in the lifetime of the universe.<br /><br />But, since checking the puzzle for correctness is polynomial, even if the  puzzle took longer than the life of the universe to solve, you could  still check to see if the solution is correct (that no number appears  more than once in each row, etc) in a reasonable amount of time. <br /><br />As mentioned above, the brute-force method outlined is non-polynomial (NP). Notice that it takes catastrophically longer - 70 orders of magnitude - to <i>solve</i> a 16-grid by brute-force, than it takes to <i>check</i> the solution to a, much larger, 100-grid.<br /><br />Admittedly, I don't know what the time function is for the method outlined above. But suffice it to say, it's more efficient than the brute-force, but still non-polynomial.<br /><br />What <a href="http://en.wikipedia.org/wiki/P%3DNP">P versus NP</a> asks, then, is<br /><br /><div style="text-align: center;"><i>if the solution to a problem can be checked in polynomial time (quickly), then does there exist an algorithm that can </i>solve<i> the problem in polynomial time?</i></div><br />At present, this is one of the great unsolved questions of mathematics and computer science, and a proof of whether or not P=NP will earn its discoverer <a href="http://en.wikipedia.org/wiki/Millennium_Prize_Problems">$1million</a>...<br /><br /><br /><b>Where's The Code?</b><br /><br />You'll probably have noticed, I've given a general, hand-wavy outline of how a program would work, and only given odd snippets of code.<br /><br />I did write a solver in Python a few years back. I'd taken a Java programming course in my first year at university, and when the lecturer discussed a tic-tac-toe (naughts and crosses) playing program, it gave me the idea of how to represent a grid in a way a computer can parse. It also made me realise that there is actually a point to <a href="http://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented programming</a>.<br /><br />Anyway, long story short, I wrote the solver 3 years ago. It's kind of sloppy and inelegant. And it can't handle the 'tricky' puzzles - although, oddly enough, according to my notebook, I had worked out a way of implementing it, but apparently never did.<br /><br />Or to put it another way, it works, but compared to the myriad others out there, it's nothing special.<br /><br />If you're interested, as I mentioned at the beginning there are plenty of other solvers out there. They might not work according to the methods discussed in this post. But you should at least have an idea of how one might work, now.<br /><br />And as a final note, these methods can also be used for hand-solving. It's generally not necessary to be so rigidly systematic, though. It's easier for humans to pick out number placements at a glace, without having to go through the whole <i>set-and-elimination</i> approach.<br /><br /><br /><b>In Case You Were Interested</b><br /><br />Here's the solution to the Su Doku at the top of the page<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-mViZK21DonI/TlBZrWwlGhI/AAAAAAAAArE/6FTyjQEmMUc/s1600/sudoku-solution.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="http://1.bp.blogspot.com/-mViZK21DonI/TlBZrWwlGhI/AAAAAAAAArE/6FTyjQEmMUc/s200/sudoku-solution.png" width="193" /></a></div>You're on your own with finishing the other ('difficult') one..<br /><br /><br />Oatzy.<br /><br /><br /><a name='more'></a><br /><br />* That is the time required for the code snippet at the top. There is a quicker approach - sum along each row, check if they equal 45 [=1+2+..+9].<br /><blockquote><div style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="color: orange;">for</span> i <span style="color: orange;">in</span> <span style="color: purple;">range</span>(0,9):</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp; &nbsp; sum = 0 </div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; <span style="color: orange;">for</span> j <span style="color: orange;">in</span> <span style="color: purple;">range</span>(0,9):</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum = sum + Grid[i][j]</div><div style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; <span style="color: orange;">if</span> sum != 45:</div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color: orange; font-family: &quot;Courier New&quot;,Courier,monospace;">return</span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"> </span><span style="color: #274e13; font-family: &quot;Courier New&quot;,Courier,monospace;">"incorrect puzzle"</span></blockquote>Do the similar for columns and boxes.<br /><br />The time required for this is ~ <i>3n^2</i>. That gives a 9-grid time of <i>243t</i>, and a 100-grid time of <i>30,000t</i>.