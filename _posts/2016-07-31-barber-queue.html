---
layout: post
title: Barber Queue
date: '2016-07-31T10:09:00.000-07:00'
author: Oatzy
tags:
- simulation
- probability
- nerd
- mathematical methods
- python
- over-thinking
- programming
- algorithm
- everyday maths
- coding
- maths
- modelling
modified_time: '2016-07-31T11:44:07.301-07:00'
thumbnail: https://2.bp.blogspot.com/-yDZ24fuerl4/V50Nz2o5pkI/AAAAAAAABso/6XOKAgsfUnMnrAZnDgLzj3b07cZOsiCKQCLcB/s72-c/p-leave-sunkcost.png
blogger_id: tag:blogger.com,1999:blog-14769935.post-4131484574323347568
blogger_orig_url: https://oatzy.blogspot.com/2016/07/barber-queue.html
---

Time was when I needed a hair cut, I'd go at noon on a weekday, when the barber's is typically empty. One of the perks of being unemployed.<br /><br />But these days I have to get my haircuts on Saturdays, before noon. Which is bad enough in itself - ideally I'd never see Saturday mornings at all. And to make matters worse, Saturday morning is also when the barbers is at its busiest.<br /><br />Hence, I found myself sat in the waiter area of a barbershop for the best part of an hour. But this got me thinking about how queuing works at a barbers.<br /><br /><br /><br /><b>First In Who's Next?</b><br /><br />At its core, the barber's queue is just a <a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)">first-in first-out</a> (FIFO) queue. But it has two interesting features:<br /><br /><br />1) <i>The queue 'structure' is unordered</i><br /><br />In general the queue 'structure' will be a waiting area with a bunch of seats. When someone new joins the queue, they're free to sit wherever. In fact, odds are, they'll pick a seat in a similar way to <a href="https://blog.xkcd.com/2009/09/02/urinal-protocol-vulnerability/">how men choose urinals</a> - attempting to maximise personal space. <br /><br />But the key point is, if someone were to just look at the queue, they wouldn't be able to tell who was next.<br /><br /><br />2) <i>Each member of the queue knows whether or not they're next</i><br /><br />Each member of the queue probably doesn't know <i>who</i> exactly is next, but they do know (with reasonable certainty) whether or not it's them.<br /><br />The way this works is relatively simple - when you join the queue, you're aware of who was there when you arrived (and of anyone who arrives after you). So when all the people who were there ahead of you have gone, you know that you're next.<br /><br /><br /><br /><b>O(M G)</b><br /><br />Okay, lets break out some Python (2.7)<br /><br />Just for fun, let's say that the capacity of the queue is fixed - i.e. the waiting area has a fixed number of seats (though in practice, people are free to stand, as I was forced to).<br /><br /><pre class="brush:py">class BarberQueue(object):<br /><br />&nbsp;&nbsp;&nbsp; def __init__(self, capacity):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; self._capacity = capacity<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; self._queue = [None]*capacity<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; self._length = 0<br /><br />&nbsp;&nbsp;&nbsp; def __len__(self):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return self._length<br /><br />&nbsp;&nbsp;&nbsp; def __str__(self):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return ', '.join(str(i) if i is not None else '_'<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for i in self._queue)<br /><br />&nbsp;&nbsp;&nbsp; def push(self, obj):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pass<br /><br />&nbsp;&nbsp;&nbsp; def pop(self):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pass<br /><br /></pre>So each member of the queue has some awareness of who is ahead of them. But they don't need to know specifically who's who, they just need to keep track of how many are remaining. And in fact, that remaining count is exactly equivalent to the member's position in the queue.<br /><br /><pre class="brush:py">class Member(object):<br /><br />&nbsp;&nbsp;&nbsp; def __init__(self, obj, position=0):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; self.value = obj<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; self._position = position<br /><br />&nbsp;&nbsp;&nbsp; def __str__(self):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return "%s (%s)" % (self.value, self._position)<br /><br />&nbsp;&nbsp;&nbsp; def is_next(self):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return self._position == 0<br /><br />&nbsp;&nbsp;&nbsp; def move_up(self):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; self._position -= 1<br /><br /></pre>So, going back to the push and pop methods<br /><br /><pre class="brush:py">def push(self, obj):<br /><br />&nbsp;&nbsp;&nbsp; if self._length == self._capacity:<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; raise Exception("Queue is full! Please come back later.")<br /><br />&nbsp;&nbsp;&nbsp; for i, m in enumerate(self._queue):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if m is None:<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; self._queue[i] = Member(obj, self._length)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; self._length += 1<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return<br /></pre><br />Here, we're picking a 'seat' by iterate over the queue looking for the first empty slot (with a value of None). We could implement any seat picking strategy we fancy, this is just the easiest.<br /><br />Once we find an empty seat, we create a new 'Member' object for the item, with position set to the current length of the queue, then increment the queue length. Also, if the queue has no empty slots, we raise an exception.<br /><br /><pre class="brush:py">def pop(self):<br />&nbsp;&nbsp;&nbsp; if self._length == 0:<br />        raise Exception("The queue is empty")<br />&nbsp;&nbsp;&nbsp; for i, m in enumerate(self._queue):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if m is not None:<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if m.is_next():<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; value = m.value<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; self._queue[i] = None<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; self._length -= 1<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m.move_up()<br />&nbsp;&nbsp;&nbsp; return value<br /><br /></pre>Here we iterate over the queue looking for the member who is 'next' (has position 0). While we're looking for the next person, we also de-increment the positions of the other members.<br /><br />Of course, this isn't how things work in practice. The barber doesn't go to each person and say "<i>are you next?</i>", "<i>how about you?</i>". They simply say "<i>who's next?</i>", and the person who believes they are next steps forward. Though arguably, that's just equivalent to asking every member concurrently. But let's not complicate things.<br /><br /><pre class="brush:py">&gt;&gt;&gt; b = BarberQueue(3)<br />&gt;&gt;&gt; for i in xrange(3):<br /> b.push(i)<br /> <br />&gt;&gt;&gt; print b<br />0 (0), 1 (1), 2 (2)<br />&gt;&gt;&gt; b.push(4)<br /><br />Traceback (most recent call last):<br />  File "&lt;pyshell&gt;", line 1, in &lt;module&gt;<br />    b.push(4)<br />  File "&lt;pyshell&gt;", line 36, in push<br />    raise Exception("Queue is full! Please come back later")<br />Exception: Queue is full! Please come back later<br />&gt;&gt;&gt; b.pop()<br />0<br />&gt;&gt;&gt; print b<br />_, 1 (0), 2 (1)<br />&gt;&gt;&gt; b.push(4)<br />&gt;&gt;&gt; print b<br />4 (2), 1 (0), 2 (1)<br />&gt;&gt;&gt; for _ in xrange(4):<br /> b.pop()<br /> <br />1<br />2<br />4<br /><br />Traceback (most recent call last):<br />  File "&lt;pyshell&gt;", line 2, in &lt;module&gt;<br />    b.pop()<br />  File "&lt;pyshell&gt;", line 46, in pop<br />    raise Exception("Empty queue!")<br />Exception: Empty queue!<br />&gt;&gt;&gt; print b<br />_, _, _<br /></pre><br />So there we have it. Of course, this type of queue isn't really useful from a programming perspective.<br /><br />All of insertion, deletion, and lookup are worst-case \(O(N)\), where N is the queue's capacity (<i>not</i> the number of people in the queue). Which is pretty much worse than all other types of queue.<br /><br /><br /><br /><b>Why do items keep disappearing from my queue?</b><br /><br />Okay, let's move away from computer-sciencey queues. There are certain behaviours in real-world queues that don't apply or wouldn't make sense to programmatic queues.<br /><br />For one, as I alluded to earlier, the capacity of the queue is not enforced - there's room for overflow, even if it means people have to stand.<br /><br />But on the other hand, when a place does get that full, people are less likely to stick around.<br /><br />In particular, we have two situations:<br /><br /><br />1) There's a non-zero <i>probability that a person will not stick around if the queue is full</i> or close to full. This probability will tend to be related to the length of the queue when that person arrives<br /><br />\[p(not join) \sim f(capacity, length)\]<br /><br />For example,<br /><br />\[p(not join) = A\left(\frac{length}{capacity}\right) - C\]<br /><br />where A and C are some constants relating to how likely the person is to stick around if the queue is 'full', and at what point they consider the place to be 'too full'.<br /><br /><br />2) There's a non-zero <i>probability that a person already in the queue will leave</i> before they're served.&nbsp; This probability will typically depend on how long the person has been waiting, and how many people are still ahead of them<br /><br />\[p(leave) \sim g(wait, position)\]<br /><br />It's interesting because as time passes, wait increases, but position  decreases. So how the probability evolves depends on how those factors  balance against one another.<br /><br />In particular, the probability evolution will likely depend on how each particular person responds to the <a href="https://youarenotsosmart.com/2011/03/25/the-sunk-cost-fallacy/">sunk-cost fallacy</a> - i.e. are they the sort to think "<i>well, I've waited this long, I might as well see it through to the end</i>", or do they think "<i>this is taking too long, I've got better things to do with my time</i>"?<br /><br />For the sake of arguing, lets go with an <a href="https://en.wikipedia.org/wiki/Exponential_function">exponential function</a> for the general form.<br /><br />For a sunk-cost person we might have<br /><br />\[p(leave) = B \cdot \exp\left(-d\cdot \frac{wait}{position}\right)\]<br /><br />This is a function where p goes to zero as position goes to zero or wait goes to infinity (B and d are some arbitrary constants). <br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-yDZ24fuerl4/V50Nz2o5pkI/AAAAAAAABso/6XOKAgsfUnMnrAZnDgLzj3b07cZOsiCKQCLcB/s1600/p-leave-sunkcost.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://2.bp.blogspot.com/-yDZ24fuerl4/V50Nz2o5pkI/AAAAAAAABso/6XOKAgsfUnMnrAZnDgLzj3b07cZOsiCKQCLcB/s1600/p-leave-sunkcost.png" /></a></div><br />Whereas for a non-sunk-cost person we might have<br /><br />\[p(leave) = B \cdot \exp\left(-\frac{d}{wait \cdot position}\right)\]<br /><br />This is a function where p goes to zero as position goes to zero, but goes to one as wait goes to infinity.<br /><br />This gives us an interesting graph<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-kmy7xE_sq1U/V50N6yjfexI/AAAAAAAABss/7tkHLXjrf8IUvpjCBJehGbxj08DJJDDyACLcB/s1600/p-leave-no-sunkcost.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://3.bp.blogspot.com/-kmy7xE_sq1U/V50N6yjfexI/AAAAAAAABss/7tkHLXjrf8IUvpjCBJehGbxj08DJJDDyACLcB/s1600/p-leave-no-sunkcost.png" /></a></div><br />Because 'position' is discrete you get this nice step function, with intervals of the probability steadily rising, then suddenly dropping. We can also see that there's a point at which probability of leaving is maximum, around the time you're in the middle of the queue. Which seems plausible.<br /><br /><br />We also have situations where a person will leave and come back later. But since, when they come back, they have to join the back of the queue, they're mathematically indistinguishable from a someone arriving for the first time.<br /><br /><br />One other complicating situation is people in groups. For example, if there's a parent and child ahead of you in the queue, the child is getting their hair cut by one member of staff, the parent is waiting; another member of staff asks 'who's next?' - is it you or the parent?<br /><br />Situations like these add uncertainty into a member's queue position, and by extension their knowledge of whether they're next.<br /><br />In that situation, we might wait to see if anyone else steps up, and if not we can assume it's our turn.<br /><br />So we have \(p(next)\), which is a <a href="https://en.wikipedia.org/wiki/Bayes_theorem">Bayesian probability</a> that updates over time to reflect whether anyone else has stepped up yet. The longer we wait with no-one stepping up, the closer our probability gets to one.<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-Uo-HxZHrACk/V54Gq0uOxUI/AAAAAAAABtY/fNr4UNWCY2AhEJGdbLECGRf0Gz7aUYTCgCLcB/s1600/p-next.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://2.bp.blogspot.com/-Uo-HxZHrACk/V54Gq0uOxUI/AAAAAAAABtY/fNr4UNWCY2AhEJGdbLECGRf0Gz7aUYTCgCLcB/s1600/p-next.png" /></a></div>Of course, if you wait too long, someone behind you might assume you're not in the queue after all and try to go ahead of you. But that's a topic for another blog.<br /><br /><br /><br /><b>Nothing's so simple that it can't be made complex</b><br /><br />I've written about queuing before, in the context of a mathematical <a href="http://oatzy.blogspot.co.uk/2011/01/model-cafe.html">model of a cafe</a>.<br /><br />The long and short of it is this - people arrive at random (following a <a href="https://en.wikipedia.org/wiki/Poisson_distribution">Poisson distribution</a>) and join the queue with some probability (see above). Each iteration, some people are served, some join the queue, some get tired of waiting and leave, etc.<br /><br />I'm going to iterate in 5 min time-step and say that a haircut takes 10-25 minutes (i.e. 2-5 steps). The exact duration is randomly generated for each customer. <br /><br />I'm going to say that on average one person shows up every 10 minutes (0.5 per step). Here's an <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.poisson.html">example</a> of how that might look over 12 steps (one hour), using the Poisson distribution: <i>[2, 0, 2, 0, 0, 0, 1, 0, 0, 1, 0, 0]</i><br /><br />I set up the simulation so that you specify some number of steps for the barbers to be considered 'open'. After that, no more people are added to the queue, but the simulation keeps running until the queue is empty.<br /><br />To begin with, I made it so that everyone who arrived stayed. <br /><br />With 2 workers, capacity 10, and an arrival rate of 0.5, the queue length typically stayed below 3. The highest I saw it go was 7, which is still comfortably within capacity.<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-VjN2AK9oQ84/V50OD0tNBpI/AAAAAAAABsw/eepI7iZX9I4KWu1p6oD_zKuMlK2cVY7tACLcB/s1600/queue-size-no-leaving.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="226" src="https://2.bp.blogspot.com/-VjN2AK9oQ84/V50OD0tNBpI/AAAAAAAABsw/eepI7iZX9I4KWu1p6oD_zKuMlK2cVY7tACLcB/s400/queue-size-no-leaving.png" width="400" /></a></div>Above is an example of how the queue size varied over time in a particular simulation.<br /><br />Increasing the arrival rate to 0.7, the average maximum queue length goes up into the low teens. And when the rate goes up to 1, the maximum queue length goes all the way up into the 30s.<br /><br /><i>Homework question</i> - how does maximum queue length vary as a function of number of workers and arrival rate?<br /><br />As I mentioned, those simulations assumed that everyone stuck around. Once you turn on probabilistic leaving, things get a bit more interesting.<br /><br />I tried both versions of the leaving probability. The result was largely the same, except that sunk-cost people tend to leave sooner - average wait before leaving 2.6 for sunk vs 7.4 for non-sunk. This is what we'd expect - people adhering to sunk cost will tend to leave before they get too invested.<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-wxwpzkhwxt8/V50OWWjWymI/AAAAAAAABs4/FkLwwV17BVkn-qec3HlyZM1rkwsK0TRuwCLcB/s1600/queue-size-w-leaving.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="223" src="https://2.bp.blogspot.com/-wxwpzkhwxt8/V50OWWjWymI/AAAAAAAABs4/FkLwwV17BVkn-qec3HlyZM1rkwsK0TRuwCLcB/s400/queue-size-w-leaving.png" width="400" /></a></div><br />In the above example, orange is a time step when someone left the queue, and red is when a newcomer decided not to join the queue. I tuned the probability constants so that people don't start leaving until we're close to or at capacity, as we'd expect in real life.<br /><br /><br /><br /><b>You and I have different ideas of what constitutes 'interesting'</b><br /><br />Going back to the original description of the barber's queue, here's an example of a full queue (bracketed numbers are queue positions)<br /><br /><blockquote class="tr_bq"><i>542b5af6 (3), 33e323cf (5), 69e60241 (6), b3f12010 (0), fc89732e (7), 991f8709 (1), a0cb93cc (2), 17186c75 (4), 57269a3e (8), 8f1b61ca (9)</i></blockquote><br />Notice how, even with the basic seat picking strategy (take the first available), the members aren't in a predictable ordered.<br /><br /><br />When we look at the waiting times, we can see some interesting things. For example <br /><blockquote class="tr_bq"><i>...<br />1c7081d1 waited 7.0<br />34 1<br />35 3<br />50be68cf waited 9.0<br />36 3<br />37 4<br />26ca11b7 waited 3.0<br />38 3<br />39 3<br />a571a7da waited 5.0</i><br /><i>...</i></blockquote><br />Here we have a person who had to wait 9 steps (45mins) to be served, followed by someone who only had to wait 3 steps (15mins). Which just goes to show, how long you wait in a queue is very much a matter of timing and luck.<br /><br /><br />It's also interesting that you can run the simulation multiple times with the exact same settings, and one time the queue will never go higher than 4, while in the the next it'll go as high as 13. This is <a href="https://en.wikipedia.org/wiki/Complexity">complexity</a> at work - various small random factors in the model interacting to produce wildly different outcomes.<br /><br /><br />So yeah. If you're interested, you can see the full <a href="https://dl.dropboxusercontent.com/u/4635169/barber.py">code here</a>. I may have gotten carried away with the object-orienting.<br /><br /><br />Oatzy.<br /><br /><br /><br /><b>[Post-Script</b><br /><br />My boss recently pointed out that it'd been over a year since my last blog post. That was another perk of being unemployed - more time to come up with dumb blog posts. Anyway, here's a quick update on some stuff.<br /><br /><br /><b>Pirate Game</b><br /><br />The last blog post was about the making of an Android game - The Pirate Game.<br /><br />The game is now finished-ish and has been released in 'beta' on the <a href="https://play.google.com/store/apps/details?id=com.cavillum.pirategame.android">Play Store</a>.<br /><br />In the <a href="http://oatzy.blogspot.co.uk/2015/06/the-pirate-game.html">previous post</a>, I mentioned that the game would eventually get a less utilitarian design. I ended up making that design myself (because I'm a control freak). I'm pretty pleased with how it turned out.<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-WkgHFr8HB9k/V50Q6sAZ13I/AAAAAAAABtI/jV3A7fcmRjghLh2Ats4bs8Y14gL3_MI4ACLcB/s1600/pg-board-mock.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://4.bp.blogspot.com/-WkgHFr8HB9k/V50Q6sAZ13I/AAAAAAAABtI/jV3A7fcmRjghLh2Ats4bs8Y14gL3_MI4ACLcB/s320/pg-board-mock.png" width="180" /></a></div>Also, following a... less than positive review, I added some new game play modes.<br /><br />I never did figure out multiplayer, though. If I ever get the time or inclination to go back to the game, that'll be on the todo list. But for the time being, I don't anticipate any updates to the game. Certainly not any time soon.<br /><br /><br /><b>New Job</b><br /><br />So yeah. I finally got a job. I'm now a Software Developer at a company called <a href="http://pixitmedia.com/">Pixit Media</a>.<br /><br />The company sells large scale 'storage solutions' to companies primarily in the VFX industry, as well as universities and other such people that do high performance computing.<br /><br />What I personally work on is primarily a Python API for the <a href="http://www-03.ibm.com/systems/uk/storage/spectrum/scale/">IBM Spectrum Scale</a> (GPFS) filesystem. You can see the <a href="http://arcapix.com/gpfsapi/">API docs online</a>. I wrote a decent amount of the documentation (and the code that's being documented).<br /><br />In particular, the '<a href="http://arcapix.com/gpfsapi/list_processing_guide.html">Getting Started With List Processing</a>' guide. Admittedly the topic is a bit niche - I doubt many readers of this blog even know of GPFS, let along have a cluster with it installed. But you might still find it interesting; you can learn some stuff about <a href="https://en.wikipedia.org/wiki/MapReduce">MapReduce</a> - a technique for taking advantage of parallelism when processing large data-sets. <br /><br />There's also the '<a href="https://github.com/arcapix/gpfsapi-examples">example scripts</a>' repository - scripts written to use the API, some of while I wrote. But, again, they're a bit niche.<br /><br />] 