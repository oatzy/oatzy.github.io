---
layout: post
title: 'Tumbling, Appendix II: Getting Formal'
date: '2011-07-24T11:51:00.000-07:00'
author: Oatzy
tags:
- graph
- nerd
- flowchart
- maths
- modelling
- tumblr
modified_time: '2011-07-24T11:51:24.913-07:00'
thumbnail: http://3.bp.blogspot.com/-3l7XAZqBGtw/TixUdH3g-iI/AAAAAAAAAkk/_CDKjJjzC2M/s72-c/sier-model.png
blogger_id: tag:blogger.com,1999:blog-14769935.post-5052413030981150886
blogger_orig_url: https://oatzy.blogspot.com/2011/07/tumbling-appendix-ii-getting-formal.html
---

<b>Pre-Ramble </b><br /><br />The problem with what I've described <a href="http://oatzy.blogspot.com/2011/06/tumbling-part-three-stochastic-spread.html">previously</a> is it's all a bit fuzzy - it's based on flow diagrams and vague descriptions, it was informal, and lacked precision. Mathematics, however, likes to have ideas clarified, by transforming them into precise, but somewhat impenetrable, collections of symbols. And who am I to argue with maths?<br /><br />Having found <a href="http://www.plosone.org/home.action">PlosOne</a> and <a href="http://arxiv.org/">arXiv</a>,  which offer open-access to academic papers, I've come across a few  papers - some related to subjects in my blogs - that have grabbed my interest. And usually I'll skim over them,  then download for reading 'at a later date'. But even just skimming, I have  started to picked up a few tricks <br /><br />Being as this is just an informal blog, there's nothing wrong with being informal. Nonetheless, there's no harm in a little practice. So this is an attempt to reintroduce the model (derived <a href="http://oatzy.blogspot.com/2011/06/tumbling-part-one-some-background.html">previously</a>) as a formal set of equations. It should be noted, though, that none of this changes or nullifies what was previously written. It simply sets it out in a more precise - albeit cryptic looking - way.<br /><br />Consider this fair warning of what's to follow. <br /><br /><br /><b>But First...</b><br /><br />For completeness, I wanted to redefine the model as a <a href="http://en.wikipedia.org/wiki/Compartmental_model">compartmental</a> one. For what it's worth. It would look and work something like this<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-3l7XAZqBGtw/TixUdH3g-iI/AAAAAAAAAkk/_CDKjJjzC2M/s1600/sier-model.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="177" src="http://3.bp.blogspot.com/-3l7XAZqBGtw/TixUdH3g-iI/AAAAAAAAAkk/_CDKjJjzC2M/s320/sier-model.png" width="320" /></a></div>In this case, <i>alpha</i> roughly reflects the average number of followers a user has, and <i>beta</i> the approximate average reblog rate. (<i>gamma = 1 - beta</i>). As discussed previously, this model isn't really sufficient. But it's nice to look at for comparison.<br /><br />In fact, the exposed state (<i>E</i>) isn't strictly necessary in this  case (more on that below). It's more of a placeholder, included for  clarity. You can actually rework the model to get rid  of it; in which case, it looks like this <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-OZil4h4sxpE/TixVbEWmTEI/AAAAAAAAAks/Z2PhkoH4YVc/s1600/sir-model.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="206" src="http://4.bp.blogspot.com/-OZil4h4sxpE/TixVbEWmTEI/AAAAAAAAAks/Z2PhkoH4YVc/s320/sir-model.png" width="320" /></a></div>Here's an example of what the output might look like (N=10,000, alpha=0.001, beta=<a href="http://oatzy.blogspot.com/2011/06/tumbling-part-two-over-threshold.html">0.14</a>),<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-5yNEgHdl78c/TixU3N15_aI/AAAAAAAAAko/QUZUGGmEWL0/s1600/sir-model-graph.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="208" src="http://4.bp.blogspot.com/-5yNEgHdl78c/TixU3N15_aI/AAAAAAAAAko/QUZUGGmEWL0/s400/sir-model-graph.png" width="400" /></a></div>With the compartmental form of the model, because the variables - such as the reblog rate - are constant, the behaviour across multiple simulations is uniform.<br /><br />In fact, for the same initial conditions, the results will always be the same. By comparison, the behaviour of the model <a href="http://oatzy.blogspot.com/2011/06/tumbling-part-three-stochastic-spread.html">previously</a> outlined can vary wildly between multiple simulations, run with the same initial conditions.<br /><br />You could modify it - maybe make the variables, literally, variable - but since we already have a perfectly good model, it's not really worth bothering.<br /><br /><br /><b>Preamble</b><br /><br />First of all, these are <a href="http://en.wikipedia.org/wiki/Difference_equations">difference equations</a> - as opposed to the differential forms used above. This is because we're working in discrete steps (rather than continuous), and because the equations aren't, strictly speaking, time dependent.<br /><br />Second, for this formal approach, we're working in <a href="http://en.wikipedia.org/wiki/Matrix_%28mathematics%29">matrices</a>. It's just easier that way.<br /><br />Now. For the simulated model, I created the network at random, as I went. This was on the assumption that it would be computationally faster. But for formality, we suppose that the entire network is either known, or else generated prior to simulation. <br /><br />At any rate, it works like this - define a matrix, M, with entries,<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-2LdnUKG2jlo/TixXOHvZtAI/AAAAAAAAAkw/q5nKGTH1P6c/s1600/matrix-def.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-2LdnUKG2jlo/TixXOHvZtAI/AAAAAAAAAkw/q5nKGTH1P6c/s1600/matrix-def.png" /></a></div>This is, essentially, a table of ones and zeros that represents some (arbitrary) network of connections - i.e. who follows who.<br /><br />As an example, in the below, the matrix on the right represents the graph on the left,<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-1I_5jQczy2k/TixXgbi0ARI/AAAAAAAAAk0/lt6iVqT8qHA/s1600/network-example.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="144" src="http://2.bp.blogspot.com/-1I_5jQczy2k/TixXgbi0ARI/AAAAAAAAAk0/lt6iVqT8qHA/s320/network-example.png" width="320" /></a></div>From this, we can calculate things like: the number of people a user, i, follows, and the number of people user i is followed by (respectively) as<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-PeRR79ChEng/TixZJrxmKAI/AAAAAAAAAk8/wyocei1k3yM/s1600/follow-follower.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-PeRR79ChEng/TixZJrxmKAI/AAAAAAAAAk8/wyocei1k3yM/s1600/follow-follower.png" /></a></div>That is, in the left case, sum along the i-th row, and in the right, sum down the i-th column.<br /><br />Next, we define <a href="http://en.wikipedia.org/wiki/Column_vector">column matrices</a> for each of the possible states. So, for example, the susceptibility matrix, S, has entries<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-pSFidvY7kfE/TixZs1GCNpI/AAAAAAAAAlA/mJZgS7AiGFo/s1600/S-state-definition.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-pSFidvY7kfE/TixZs1GCNpI/AAAAAAAAAlA/mJZgS7AiGFo/s1600/S-state-definition.png" /></a></div>That is, if user <i>i</i> is susceptible at time n, then this will be indicated by a one in the i-th row of that state matrix. Otherwise its value is zero.<br /><br />We can then define an operator to calculate the number of people in that given state as<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-MHkPKyZwm4U/TixaSy0F0hI/AAAAAAAAAlE/rfGCiKNUOEc/s1600/mod-S.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-MHkPKyZwm4U/TixaSy0F0hI/AAAAAAAAAlE/rfGCiKNUOEc/s1600/mod-S.png" /></a></div>Essentially, this counts the number of ones in whichever state matrix. Which leads to the equation<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-XIvGmUO9L2k/Tixb9xU_hyI/AAAAAAAAAlM/-AMYp0GhFGQ/s1600/population-size.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-XIvGmUO9L2k/Tixb9xU_hyI/AAAAAAAAAlM/-AMYp0GhFGQ/s1600/population-size.png" /></a></div>Which basically says that the sum of the number of people in each state equals the total population size.&nbsp; Or in other words, that everyone in the population has to be in one of the three states.<br /><br />Finally, we define a function, <i>sigma</i>, that looks like this,<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-leGG-SYYGcs/Tixc1sZGM0I/AAAAAAAAAlQ/nvltWjS5iO4/s1600/sigma.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-leGG-SYYGcs/Tixc1sZGM0I/AAAAAAAAAlQ/nvltWjS5iO4/s1600/sigma.png" /></a></div>This is the function for threshold testing, described previously. In essence, it takes a matrix of the users' thresholds, <i>t</i>, and their assessments of a given post, <i>A(p)</i>, and returns a matrix of ones and zeros representing whether or not each user will 'reblog' that post.<br /><br /><br /><b>The Model</b><br /><br />So now, we can define our set of equations. Brace yourself,<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-U8RG17cUE7c/TixdaAvOhII/AAAAAAAAAlU/9VqcKGtw__Y/s1600/Tumblr-model-equations.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-U8RG17cUE7c/TixdaAvOhII/AAAAAAAAAlU/9VqcKGtw__Y/s1600/Tumblr-model-equations.png" /></a></div>The typical initial conditions will be,<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-ofRSDlYpmuA/TixdlnRa62I/AAAAAAAAAlY/dn2kpQ0GlCk/s1600/initial-conditions.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="101" src="http://2.bp.blogspot.com/-ofRSDlYpmuA/TixdlnRa62I/AAAAAAAAAlY/dn2kpQ0GlCk/s400/initial-conditions.png" width="400" /></a></div>In theory, this model shouldn't be significantly different from the one previously outlined - though, admittedly, I haven't tested this assumption.<br /><br />Ultimately, the behaviour of the system depends on the matrices <i>M</i>, <i>t</i>, and <i>A(p)</i>. And if these are predefined and fixed, then the behaviour will be the same over multiple simulations. But if these are newly generated (at random) for each simulation, then the behaviour will be variable, as before.<br /><br />In this case, <i>E(n)</i> is really more a function, upon which the other equations depend, rather than a state in and off itself. In particular, no-one exists in that state for any longer than it takes for them to be redistributed into their proper state (for that iteration). This is similar to the redundancy of the E state in the compartmental model above, except that this time it's not so easily written out.<br /><br />And that's basically it.<br /><br /><br />Oatzy.<br /><br /><br />[<i>Hoping I didn't make any mistakes in my own model.</i>]